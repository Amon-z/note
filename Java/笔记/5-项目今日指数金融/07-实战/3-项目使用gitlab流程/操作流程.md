# 阶段1-构建账户信息

## 1.1 管理员分配账户

### 方式1-推荐

企业正常使用gitlab时，一般由项目经理(超级管理员)手动创建开发者账户信息，然后将账户发送给开发者，以便登录使用；

流程如下：

![1652674551712](./assets/1652674551712.png)

![1652674925959](./assets/1652674925959.png)

![1652675188934](./assets/1652675188934.png)

点击创建用户按钮；

创建完用户后，可能指定的邮件地址接收不到账户激活信息，我们只直接添加密码信息：

![1652190897534](./assets/1652190897534.png)



### 方式2-临时开启注册功能自行注册

处于工作量的考虑，对于我们来说，超级管理员也可临时开启登录功能（只有超级管理员才拥有该权限）：

操作流程如下：

![1652674551712](./assets/1652674551712.png)



![1652674591956](./assets/1652674591956.png)

![1652674674962](./assets/1652674674962.png)

点击保存更改，普通用户就可以正常注册了；

这样访问http://47.96.143.141:9999/users/sign_in也可注册；

点击注册：

![1652678183699](./assets/1652678183699.png)

填写账户信息：

![1652678156904](./assets/1652678156904.png)

选择账户的角色：

![1652678228941](./assets/1652678228941.png)

点击get started 自动登录进入操作界面：

![1652678268114](./assets/1652678268114.png)

选择界面汉化：

![1652678281576](./assets/1652678281576.png)



说明：

~~~tex
【1】Gitlab用户在组中有角色权限：Guest、Reporter、Developer、Master、Owner
【2】Gitlab权限管理
	Guest：可以创建issue、发表评论，不能读写版本库，访客；
	Reporter：可以克隆代码，不能提交，QA、PM可以赋予这个权限，报告者; 可以理解为测试员、产品经理等，一般负责提交issue等；
	Developer：可以克隆代码、开发、提交、push，RD可以赋予这个权限，开发者；
	Master：可以创建项目、添加tag、保护分支、添加项目成员、编辑项目，核心RD负责人可以赋予这个权限，主要负责对master分支进行维护；
	Owner：可以设置项目访问权限 - Visibility Level、删除项目、迁移项目、管理组成员，开发组leader可以赋予 这个权限，一般是项目经理；
【3】Gitlab中的组和项目有三种访问权限：Private、Internal、Public
        Private：只有组成员才能看到★★★
        Internal：只要登录的用户就能看到
        Public：所有人都能看到
        开源项目和组一般设置为public
~~~



# 阶段2-添加用户开发组

## 2.1.构建用户组

构建项目组一般是由项目经理来构建：

~~~tex
注意事项：我们的组名：jrzs_147_g1，格式：项目名称_期_gN
~~~



![1652189939721](./assets/1652189939721.png)



----------------------------------

![1652189977649](./assets/1652189977649.png)

---

![1652190291062](./assets/1652190291062.png)

---

![1652190495741](./assets/1652190495741.png)



##  2.2. 用户组添加用户

![1652191071202](./assets/1652191071202.png)

---

![1652191105276](./assets/1652191105276.png)

---

# 阶段3-构建项目

## 3.1.用户组构建新项目

![1652191206369](./assets/1652191206369.png)

---

![1652191227726](./assets/1652191227726.png)



---

![1652191264919](./assets/1652191264919.png)

## 3.2 配置ssh免密登录

配置ssh免密登录（可选项）：

1) 生成秘钥指令：

```shell
ssh-keygen -t rsa (3个回车)
```

2) 赋值pub公钥，并在gitlab中配置，过程与配置gitee一致：

![1652694703529](./assets/1652694703529.png)



![1652694763749](./assets/1652694763749.png)

## 3.3 配置本地仓库开发人员信息

接下来，git init初始化本地git仓库，并设置用户相关信息，这样提交时就会显示对应配置的用户名信息了：

~~~shell
git config user.name 'lisi1'
git config user.email '666@163.com'
~~~

开发组长将初始化代码提交到远程仓库，然后构建dev分支：

![1652695324988](./assets/1652695324988.png)

![1652695346447](./assets/1652695346447.png)

平台构建好dev分支后（也可本地构建dev分支，然后推送到远程），本地需要git fetch刷新分支最新配置；

## 3.4.设置分支保护

团队开发时为了避免一些重要的开发分支（master）被意外篡改，管理人员需要将这些重要的分支设置分支保护，这样普通开发人员就不能直接将代码进行推送和合并了，需要专门的分支管理人员（开发组长）维护重要分支的提交、合并操作；

设置分支保护流程如下：

![1652695696351](./assets/1652695696351.png)

---

![1652695823935](./assets/1652695823935.png)

临时禁用自动持续集成：

![1654650046001](./assets/1654650046001.png)

## 3.5.开发人员开发流程

### 1）普通开发者代码拉取

构建一个文件夹，然后在文件夹中克隆工程基础代码：

~~~shell
#因为项目的私有的，所以克隆代码时，要制定对应的账户和密码，否则无权限下载；
#格式：git clone http://账号:密码@47.96.143.141:9999/jrzs_142_tmp_g2/jrzs_stock_tmp.git
$ git clone http://lisi2:12345678@47.96.143.141:9999/jrzs_142_tmp_g2/jrzs_stock_tmp.git
~~~

然后使用idea打开代码，并设置当前用户信息：

~~~shell
C:\Users\46035\Desktop\lisi2\jrzs_stock_tmp>git config user.name
陆庆辉
C:\Users\46035\Desktop\lisi2\jrzs_stock_tmp>git config user.email
777@163.com
~~~

### 2）检出dev分支

接下来开发人员手动检出远程dev分支：

![1652696556897](./assets/1652696556897.png)

![1652696589506](./assets/1652696589506.png)

这样本地就会构建一个dev分支！

### 3）基于dev分支检出功能分支

对于普通开发人员来说，工作都围绕dev分支展开，而实际开发中，为了避免直接污染dev分支，一般开发人员会在dev的基础上checkout出一个功能分支：比如feature_login

![1652696705671](./assets/1652696705671.png)



### 4）合并功能分支到dev分支

在功能分支下开发完毕后，将代码合并到dev分支下：

![1652697000654](./assets/1652697000654.png)

![1652697038136](./assets/1652697038136.png)

到此，feature_login代码就合并到dev分支下了！

### 5）推送远程dev

开发人员自测代码无问题后，就可以将代码提交到远程dev分支了：

![1652697142996](./assets/1652697142996.png)

说明：开发者推送代码到dev后，一般测试人员会介入，测试ok后，分支管理人员会进行受保护分支的合并工作（在自动化工作流汇中，测试通过后，会自动合并）；

## 3.6.管理员合并代码到master

### 1) 流程

管理员在合并代码之前，先把最新的dev代码拉去到本地，然后做基本的审查工作：

![1652697555636](./assets/1652697555636.png)

![1652697583012](./assets/1652697583012.png)

此时本地仓库拉取到了最新的dev代码，代码检查无误后合并到master分支：

![1652697741803](./assets/1652697741803.png)

代码合并到master分支后，提交到远程的master分支即可；

---

### 2）最终效果

不同的开发人员共同维护master和dev分支，最终提交记录线：

![1654911210724](./assets/1654911210724.png)

反例：

![1654911202526](./assets/1654911202526.png)

> 跨域不同的分支 合并代码，容易丢失代码；

## 3.7.回滚操作

通过revert提交则会产生新的提交记录；

本质上就是在新的提交记录下做了逆向操作，实现回滚；

![1652698391771](./assets/1652698391771.png)



获取通过reset回滚时，最新的提交记录不会消失；

![1652699125909](./assets/1652699125909.png)

## 3.8.GIT打TAG

### 1）打标签概述

当项目开发到一些重要阶段后，会进行软件不同版本的发布部署工作，显然如果不记录下这些重要的历史节点，后期从繁杂的提交流水看中查找会变得非常艰难，所以git提供了为开发节点打标签的功能：

![1654657173890](./assets/1654657173890.png)

---

![1654657305526](./assets/1654657305526.png)

### 2）tag其它

详见：day07-实战\资料\3.项目使用GitLab流程\git打tag规范；

